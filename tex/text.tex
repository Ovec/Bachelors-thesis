% ============================================================================ %
% Encoding: UTF-8 (žluťoučký kůň úpěl ďábelšké ódy)
% ============================================================================ %

% ============================================================================ %
\nn{Introduction}
The cloud has made our work easier. We no longer have to physically connect new machines to the network, configure network connections, add disks, or even plug in virtual ones. Kubernetes, together with the cloud, can automatically allocate new resources for our applications and, thanks to operators, can even create entire database clusters with high availability. Thanks to operators, it can also automatically set up scaling or backups. It can even restore an entire database system from a backup. This paper is focused specifically on Kubernetes operators for the popular Postgres database management system. Its goal is to find Operators for Postgres. To evaluate their pros and cons. To test them and recommend the best one.

% ============================================================================ %
\cast{Theory}

\n{1}{Background}
This chapter introduces the key technologies used in this thesis including Postgres, Kubernetes, and Kubernetes operators.
\n{2}{Postgres}
PostgreSQL is a powerful object-relational database management system (ORDBMS) derived from the POSTGRES package written at the University of California at Berkeley. \cite{docuPgwhatIsPg} \cite{pg14introduction} The first version of POSTGRES was released in June 1989. POSTGRES has been used in many applications, including financial data analysis systems, asteroid tracking databases, medical information database, and several geographic information systems. The size of external community users has nearly doubled by 1993. \cite{docuPgBriefHistory}

POSTGRES was using its POSTQUEL query language from version one until 1995, when Andrew Yu and Jolly Chen introduced SQL to POSTGRES. The name has changed to Postgres95. Postgres95 was completely ANSI C code reduced by 25 \% and was 30 – 50 \% faster than Postgres 4.2.  \cite{docuPgBriefHistory}

It was clear by 1996 that the name would not stand the test of time therefore it has been renamed to PostgreSQL. As stated by PostgreSQL documentation \cite{docuPgBriefHistory}: “Many people continue to refer to PostgreSQL as “Postgres” (now rarely in all capital letters) because of tradition or because it is easier to pronounce. This usage is widely accepted as a nickname or alias.“ This thesis will use Postgres as an alias for PostgreSQL as well.

More than 30 years after the first version Postgres has been considered the most used ORDBMS for professional developers by Stack Overflow survey \cite{so2022survey}. According to Riggs and Ciolli \cite{pg14introduction}: “The PostgreSQL feature set attracts serious users who have serious applications. Financial services companies may be PostgreSQL's largest user group, although governments, telecommunication companies, and many other segments are strong users as well.“ It is fully ACID compliant \cite{juba2015learningTransactionIsolation} and supports many kinds of data models such as relational, document, and key/value. \cite{pg14introduction}

%Database engines survey https://db-engines.com/en/ranking
%Describe postgres usage
%Describe scaling etc.
%DSK time consuming Postgres

\n{2}{Kubernetes}
Kubernetes, also known as K8s, is an open-source platform for automating deployment, scaling, and management of containerized applications. It provides a way to manage and orchestrate containers, which are units of software that package up an application and its dependencies into a single, isolated package that can run consistently on any infrastructure. \cite{vayghan2019kubernetes}

As described by Kubernetes Documentation \cite{docuKubeComponents} Kubernetes provides several key features, including:
\begin{itemize}
  \item \textbf{Service discovery:} A container can be exposed by Kubernetes either through its DNS name or its own IP address.
  \item \textbf{Load balancing:} In the case of high traffic to a container, stability of the deployment can be ensured by Kubernetes load balancing and distributing the network traffic.
  \item \textbf{Storage Orchestration:} Storage orchestration in Kubernetes allows for the automatic mounting of a storage system of choice, including local storage, public cloud providers, and others.
  \item \textbf{Automated rollouts and rollbacks:} The desired state of deployed containers can be described using Kubernetes, and the actual state can be changed to the desired state at a controlled rate. For instance, the automation of Kubernetes can be utilized to create new containers for the deployment, remove existing containers, and transfer all their resources to the newly created container.
  \item \textbf{Automatic bin packing:} A cluster of nodes for running containerized tasks is provided to Kubernetes. The amount of CPU and memory required by each container is specified to Kubernetes. The optimal utilization of resources can be achieved by Kubernetes fitting the containers onto the nodes.
  \item \textbf{Self healing:} Containers that fail are restarted by Kubernetes, those that do not respond to the user-defined health check are replaced or killed, and they are not advertised to clients until they are deemed ready to serve.
  \item \textbf{Secret and configuration management:} Sensitive information, such as passwords, OAuth tokens, and SSH keys, can be stored and managed by Kubernetes. The deployment and updating of secrets and application configuration can be done without the need to rebuild container images and without the exposure of secrets in the stack configuration.
\end{itemize}
\n{3}{Kubernetes Components}
Kubernetes cluster is composed of a set of worker machines that run containerized applications called nodes. Each cluster must have at least one node. \cite{docuKubeComponents}
\obr{The components of a Kubernetes cluster \cite{docuKubeComponents}}{}{1}{graphics/kubernetes_cluster_components.png}

The Kubernetes control plane is the management system of a Kubernetes cluster, responsible for maintaining the desired state of the cluster. It consists of multiple components that work together to manage the cluster and its resources, including pods, services, and volumes. The key components of control plane are \cite{masteringKubernetesConcepts}:
\begin{itemize}
  \item \textbf{kube-apiserver:} Acts as the front-end for the Kubernetes API and exposes the API to other components. \cite{docuKubeComponents}
  \item \textbf{etcd:} Highly available distributed key-value store that serves as the backing store for the cluster's configuration data. \cite{Dobies2020}
  \item \textbf{kube-scheduler:} Assigns work to nodes in the cluster, such as scheduling pods to run on nodes. \cite{kubeUpAndRunningPods}
  \item \textbf{kube-controller-manager:} Monitors the cluster's state and makes adjustments as necessary to maintain the desired state. \cite{masteringKubernetesConcepts}
  \item \textbf{cloud-controller-manager:} Manages cloud-related tasks such as node creation and management, volume management, and load balancing, allowing the other components of the control plane to focus on their specific responsibilities. Cloud manager is optional. Can be avoided when Kubernetes not used in cloud. \cite{docuKubeComponents}
\end{itemize}
\textbf{Node components:}
Node components in a Kubernetes cluster run on each node and provide crucial functionality for the operation of containers on that node. \cite{docuKubeComponents}
\begin{itemize}
  \item \textbf{kubelet:} Is responsible for communicating with the control plane and ensuring that containers are running and healthy. \cite{kubeUpAndRunning}
  \item \textbf{kube-proxy:} Is responsible for maintaining network rules on the nodes, allowing network communication to the containers. It enables the containers in a pod to communicate with other containers and the outside world, and performs tasks such as load balancing and traffic routing. \cite{kubeUpAndRunning}
  \item \textbf{container runtime:} Is responsible for running containers. \cite{docuKubeComponents}
\end{itemize}

\n{3}{Kubernetes Concepts}
Pod is the smallest deployable unit that can be created in Kubernetes. \cite{docuKubePods} A Pod in Kubernetes is comprised of multiple containers and storage volumes that are run together within the same execution environment. Pods, not individual containers, are considered to be the smallest unit that can be deployed in a cluster. As a result, all containers included in a single Pod will always run on the same machine. \cite{kubeUpAndRunningPods}

A Pod's specifications are outlined in a Pod manifest, which is simply a JSON or YAML text file that represents the Kubernetes API object. Kubernetes follows a declarative configuration approach, where the system's desired state is defined in a configuration file, and the service then implements the necessary changes to make the desired state a reality. \cite{docuKubeStaticPod}

ReplicaSet’s purpose is to ensure a consistent number of replica Pods are running at all times. It is commonly used to guarantee a specified number of identical Pods are available. However, a Deployment is a more advanced concept that oversees ReplicaSets and provides a more streamlined way to make updates to Pods. It also offers additional features. As a result, it's advisable to use Deployments instead of directly utilizing ReplicaSets, unless you have specific update requirements or don't need to make updates at all. \cite{docuKubeReplicaset}

Service is an abstraction layer and defines a group of Pods and the method to access them (often referred to as a micro-service). The group of Pods targeted by a Service is usually specified through a selector. The Service abstraction makes this possible by enabling the decoupling of components. \cite{docuKubeSevice}

\textbf{TBD service, service discover, volumes etc, stateful vs stateles}

\n{2}{Operators}
TBD - operators capability levels
TBD - where to find operators (best operator are from the developers of postgres)
TBD - define Operator hub

\n{2}{Running Postgres in Kubernetes}
TBD - statefull set, risk of loosing data without statefull set, high availability, scaling


\n{1}{Database System Lifecycle}
The database system itself is a software like any other. It is therefore also subject to the same life cycle as software.
As depicted in figure 2.1 application lifecycle consists of three main parts. It is the governance part, development, and operations. For this thesis, only the operations part is relevant because it is the only part we are able to control.
\obr{Application Life Cycle \cite{ALM}}{}{1}{graphics/aplication-lifecycle.png}

Operation is the process of running and managing the application, which starts with deployment and continues until the application is taken out of service. This aspect of the application lifecycle management covers the release of the application into production, ongoing monitoring, and other related tasks. \cite{ALM}

TBD: connect to capability levels of Operator (define related tasks, chose the capability that would suit them all)



\n{1}{Search for Postgres Operators}
TBD: connect Operators (where to find operators)

TBD: describe CloudNativePG and Patroni

TBD: describe EDB licence

TBD: each operator security Artifact hub https://artifacthub.io/packages/olm/community-operators/postgresql

TBD: What does Percona different to Crunchy to EDB?

TBD: Postgres update every three months https://access.crunchydata.com/documentation/postgres-operator/5.3.0/tutorial/update-cluster/

As previously stated in the section on Operators, the most suitable operators for a software are those developed by the software developers themselves, as they possess an in-depth understanding of the software. Regrettably, no such operator has been created for Postgres.

Operator Hub presents eight operators with varying levels of capabilities, including Crunchy Postgres for Kubernetes by Crunchy Data, EDB Postgres for Kubernetes by EnterpriseDB Corporation, Ext Postgres Operator by movetokube.com, Percona Operator for PostgreSQL by Percona, Postgres-Operator by Zalando SE, Postgresql Operator by Openlabs, and PostgreSQL Operator by Dev4Ddevs.com.

Of the eight operators available through Operator Hub, only three meet our minimum capability requirement of Deep Insight, namely: Crunchy Postgres for Kubernetes, EDB Postgres for Kubernetes, and Percona Operator for PostgreSQL. As a result, only these three will be subjected to testing and evaluation.

\pagebreak
\n{2}{Crunchy Postgres for Kubernetes}
Crunchy Postgres for Kubernetes (PGO) is a Postgres Operator provided by Crunchy Data, which offers a declarative solution for the management of PostgreSQL clusters, with a focus on automation.
Crunchy Data is a company that specializes in providing open-source software solutions for Postgres. The company also provides a range of support, consulting, and training services to help organizations implement and optimize their Postgres deployment. \cite{Crunchy}:

PGO’s capabilities are the following:
\begin{itemize}
  \item \textbf{Postgres Cluster Provisioning:} PGO is able to create \cite{CrunchyDocCreate}, update \cite{CrunchyDocUpdate} or delete Postgres cluster \cite{CrunchyDocDelete}
  \item \textbf{High Availability:} High availability is achieved by adding additional nodes. PGO uses a synchronous replication technique. \cite{CrunchyDocHA}
  \item \textbf{Postgres updates:} PGO is able to apply minor patches. \cite{CrunchyDocMinorUpdates}
  \item \textbf{Backups:} PGO backup capabilities features: automatic backup schedules, backup to multiple locations, backup to cloud providers (AWS S3, Google Cloud Storage, Azure Blob), ad hoc backups, and backup encryption. \cite{CrunchyDocBackups}
  \item \textbf{Disaster Recovery:} PGO is capable of Point In Time recovery, in place Point in Time Recovery, restore of an individual database. \cite{CrunchyDocDisasterRecovery}
  \item \textbf{Cloning:} PGO is able to clone cluster. \cite{CrunchyDocDisasterRecovery}
  \item \textbf{Monitoring:} Monitoring is provided by Prometheus, Grafana, and Alertmanager. \cite{CrunchyDocMonitoring}
  \item \textbf{Connection Pooling:} PgBouncer connection pooler from Postgres is part of PGO. \cite{CrunchyDocConnectionPooling}
\end{itemize}

The current stable version of PGO is 5.3.0 was released on 13th January 2023 and has one critical vulnerability, 7 highly critical vulnerabilities, 31 medium, and 31 low. \cite{ArtifactHubCrunchy}
PGO is compatible with following platforms: Kubernetes 1.22-1.25, OpenShift 4.8-4.11, Rancher, Google Kubernetes Engine (GKE), including Anthos, Amazon EKS, Microsoft AKS, VMware Tanzu. \cite{CrunchyDoc}

PGO is distributed under the Apache License 2.0, an open-source license that allows for both commercial and non-commercial use. With regards to capability, PGO is considered to have the highest level, labeled as Autopilot. \cite{OperatorHubCrunchy}

PGO consists of the following components \cite{CrunchyPGOGit}:
\begin{itemize}
  \item Postgres:
        \begin{itemize}
          \item PostgreSQL Contrib Modules
          \item PL/Python + PL/Python 3
          \item PL/Perl
          \item PL/Tcl
          \item pgAudit
          \item pgAudit Analyze
          \item pg\_cron
          \item pg\_partman
          \item pgnodemx
          \item set\_user
          \item TimescaleDB
          \item wal2json
        \end{itemize}
  \item pgBackRest
  \item pgBouncer
  \item pgAdmin 4
  \item pgMonitor
        \begin{itemize}
          \item pgMonitor
          \item Prometheus
          \item Grafana
          \item Alertmanager
        \end{itemize}
  \item Patroni
  \item LLVM (JIT compilation)
\end{itemize}

\obr{PGO’s architecture \cite{CrunchyDocArchitecture}}{}{1}{graphics/pgo_architecture.png}


\pagebreak

\n{2}{EDB Postgres for Kubernetes}
The EDB Postgres for Kubernetes (EDBO) is a fully supported operator that has been designed, developed, and maintained by EnterpriseDB Corporation. It provides comprehensive coverage of the entire lifecycle of highly available PostgreSQL database clusters with a primary/standby architecture, utilizing native streaming replication. The operator is based on the open-source CloudNativePG operator and offers additional benefits. \cite{OperatorHubEDB}

EnterpriseDB (EDB) is a software company that provides enterprise-class PostgreSQL software and services. EDB is a leading provider of PostgreSQL technology, offering a range of products and services designed to help organizations adopt, deploy, and manage PostgreSQL databases. \cite{EDB}

EDBO’s capabilities are the following:
\begin{itemize}
  \item \textbf{Postgres Cluster Provisioning:} PGO is able to create, update or delete Postgres cluster. \cite{EDBdocuCapabilityLevels}
  \item \textbf{High Availability:} High availability is achieved by adding additional nodes. PGO uses a synchronous replication technique. \cite{EDBdocuReplication}
  \item \textbf{Postgres updates:} EDBO is able to apply minor patches. \cite{EDBdocuUpdates}
  \item \textbf{Backups:} EDBO backup capabilities features: automatic backup schedules, backup to multiple locations, backup to cloud providers (AWS S3, Google Cloud Storage, Azure Blob), on-demand backups, and backup encryption \cite{EDBdocuBackup}\cite{EDBdocuTDE}. Due to EDB’s own backup software Barman backup compression is available also. \cite{EDBdocuBackup}
  \item \textbf{Disaster Recovery:} EDBO is capable of Point In Time recovery. Database recovery was not mentioned in the documentation. \cite{EDBdocuBackup}
  \item \textbf{Cloning:} EDBO is able to create cluster replicas. \cite{EDBdocuReplication}
  \item \textbf{Monitoring:} Monitoring can be provided by the additional installation of Prometheus, and Grafana, and Alertmanager. \cite{EDBdocuQuickstart}
  \item \textbf{Connection Pooling:} Is provided by native Postgres pooler PgBouncer. \cite{EDBdocuConnectionPooling}
  \item \textbf{Customization:} EDBO provides a wide area of Postgres customization such as max parallel workers tuning or WAL configuration \cite{EDBdocuConfiguration}
\end{itemize}

EDB provides an interactive demo of their Operator online\footnote[1]{EDBO’s online demo http://bit.ly/3xr7iD3}.

The current stable version of EDBO is 1.19.2. was released on 15th February 2023 and has 27 medium vulnerabilities, and 31 low vulnerabilities\footnote[2]{Observed on 16th February at https://artifacthub.io/packages/olm/community-operators/cloud-native-postgresql}. EDBO is distributed under the EDB Limited Usage License Agreement, a proprietary license that is specific to software provided by EnterpriseDB Corporation. A license key is always required for the operator to work. With regards to capability, EDBO is considered to have the highest level, labeled as Autopilot. \cite{EDBdocu}

EDBO consists of the following components \cite{EDBdocu} \cite{EDBdocuQuickstart}:
\begin{itemize}
  \item Postgres:
        \begin{itemize}
          \item CloudNativePG
        \end{itemize}
  \item Monitoring
        \begin{itemize}
          \item Prometheus
          \item Grafana
          \item Alertmanager
        \end{itemize}
\end{itemize}


\obr{EDBO’s architecture \cite{EDBdocuConnectionPooling}}{}{1}{graphics/edbo_architecture.png}


\n{2}{Percona Operator for PostgreSQL}
Percona is a company that provides services and solutions for open-source database technologies. It offers expertise, support, and software for MySQL, MongoDB, and PostgreSQL. The company's offerings help organizations manage their open-source databases and ensure optimal performance, security, and scalability. \cite{Percona}

The current stable version of PPO is 1.3.0 and it is compatible with a minimum Kubernetes version of 1.11.0. The upcoming version 2.0.0 is not yet production ready but will be included in the evaluation. PPO is distributed under the Apache License 2.0, an open-source license that allows for both commercial and non-commercial use. With regards to capability, PPO is considered to have the second highest level, labeled as Deep Insights. \cite{OperatorHubPercona}

PPO’s main features are the same as PGO’s \cite{OperatorHubPercona}


\tab{Comparison of selected Operators}{tab:priklad2}{1}{|l|l|l|l|l|}{
  \hline
  & PGO 5.3.0 & EDBO 1.18.1 & PPO 1.3.0 & PPO 2.0.0\\ \hline
  Release date & 1.22.0 & unknown & 1.21.0 & 1.22.0 \\ \hline
  Minimal K8s version & 1.22.0 & unknown & 1.21.0 & 1.22.0 \\ \hline
  Postgres versions supported & 15 & EDBO 1.18.1 & PPO 1.12.0 \\ \hline
  Licence & PGO 5.3.0 & EDBO 1.18.1 & PPO 1.12.0 \\ \hline
  Capability & Autopilot & Autopilot & Deep Insights & Deep Insights  \\ \hline
  Security & PGO 5.3.0 & EDBO 1.18.1 & PPO 1.12.0 \\ \hline
}

% \emph{F} & (jedna) & (dva) & (tři) & (čtyři) & (pět) & 300 \\ \hline



\n{1}{Architecture}
%\obr{2022 Developer Survey \cite{so2022survey}}{}{1}{graphics/postgres_stack_overflow_survey.png}





\n{1}{Nadpisy a podnadpisy}
Na této stránce je k vidění způsob tvorby různých úrovní nadpisů.

\n{2}{Podnadpis A}
Text

\n{2}{Podnadpis B}
Text

\n{2}{Podnadpis C}
Text

\n{3}{Podpodnadpis alfa}
Text

\n{3}{Podpodnadpis beta}
Text

\n{3}{Podpodnadpis gama}
Text

\n{2}{Podnadpis D}
Text


\n{1}{Vkládání obrázků, tabulek a citací}
Níže následují ukázky vložení obrázku, tabulky a různorodých citací.


\n{2}{Obrázek}
Obrázek \ref{fig:logo} prezentuje logo Fakulty aplikované informatiky.

% Obrázek lze vkládat pomocí následujícího zjednodušeného stylu, nebo klasickým LaTex způsobem
% Pozor! Obrázek nesmí obsahovat alfa kanál (průhlednost). Jde to totiž proti požadovanému standardu PDF/A.
\obr{Popisek obrázku}{fig:logo}{0.5}{graphics/logo/fai_logo_cz.png}


\n{2}{Tabulka}
Tabulka \ref{tab:priklad} obsahuje dva řádky a celkem 7 sloupců.

% Tabulku lze vkládat pomocí následujícího zjednodušeného stylu, nebo klasickým LaTex způsobem
\tab{Popisek tabulky}{tab:priklad}{0.65}{|l|c|c|c|c|c|r|}{
  \hline
  & 1 & 2 & 3 & 4 & 5 & Cena [Kč] \\ \hline
  \emph{F} & (jedna) & (dva) & (tři) & (čtyři) & (pět) & 300 \\ \hline
}

% ============================================================================ %

% Pokud Vaše práce obsahuje analytickou část, stačí odkomentovat nasledujících dva řádky
%\cast{Analytická část}
%\n{1}{Nadpis}


% ============================================================================ %
\cast{Praktická část}
\n{1}{Nadpis první kapitoly praktické části}
Text je text


% ============================================================================ %
\nn{Závěr}
Text závěru.


% ============================================================================ %
